Goal: to make more complex model

Insight: all those neurons in deep learning are just weights, the same as in the most simple model. and also relu (0 if x < 0 or x)

Action: here ive added "secret" layer (16 kinda neurons) aside from final 8 weights. obviously i had to change the way 
how final layers (and their probabilities) went back to vectors (ive made that last layers changed their weights the 
same way (weights_loss) but * not on vectors but neurons output (logits) and neurons by modified gradient of final layer
* relu * vectors). well thats it for right now. this is not tree, idk how to call it, but i would call: expanded linear 
function with nonlinearty.

import math import random 
dataset = [[0.1, 0.8, 1.0, 1.0], [0.9, 0.2, 0.1, 1.0], [0.2, 0.9, 0.7, 1.0]] 
target = [[1, 0], [0, 1], [1, 0]] lr = 0.05 
neurons = [[random.uniform(-0.1, 0.1) for _ in range(4)] for _ in range(4)] 
finals = [[random.uniform(-0.1, 0.1) for _ in range(4)] for _ in range(2)] 
def relu(x): return max(0, x) def relu_deriv(x): return 1 if x > 0 else 0
for epoch in range(500): 
  total_loss = 0 
  for i in range(len(dataset)): 
    vectors = dataset[i] 
    neurons_logits = [relu(sum(v * w for v, w in zip(vectors, row))) for row in neurons] 
    logits = [sum(v * w for v, w in zip(neurons_logits, row)) for row in finals] 
    probs = [math.exp(l) / sum(math.exp(x) for x in logits) for l in logits] 
    weights_loss = [probs[j] - target[i][j] for j in range(2)] 
    neurons_loss = [0.0] * 4 for j in range(4): 
    error = sum(weights_loss[k] * finals[k][j] for k in range(2)) 
    neurons_loss[j] = error * relu_deriv(neurons_logits[j]) for j in range(2): 
    for k in range(4): 
      finals[j][k] -= lr * weights_loss[j] * neurons_logits[k]
    for j in range(4): for k in range(4): 
      neurons[j][k] -= lr * neurons_loss[j] * vectors[k] 
  if epoch % 100 == 0: print(f"Epoch {epoch} завершена")

test_game = [0.1, 0.9, 0.8, 1.0] 
l1 = [relu(sum(v * w for v, w in zip(test_game, row))) for row in neurons] 
l2 = [sum(v * w for v, w in zip(l1, row)) for row in finals] 
final_probs = [math.exp(l) / sum(math.exp(x) for x in l2) for l in l2] 
print(f"Новая игра: Хит {final_probs[0]:.2%}, Провал {final_probs[1]:.2%}")
